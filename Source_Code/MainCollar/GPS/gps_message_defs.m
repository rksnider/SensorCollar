function next_meminfo = gps_message_defs (miffile, start_meminfo, mem_bytes)
%GPS_MESSAGE_DEFS   Build and output GPS Message defs to MIF and VHDL files.
% usage next_meminfo = gps_message_defs (miffile, start_address)
%      next_meminfo  = Address of [ROM RAM RAM_BLOCK RAM_TEMP MSG
%                                  FLD MSG_BUFF] on return.
%         miffile    = File handle of the MIF file the ROM contents is to go
%                      into.
%     start_meminfo  = Next available address of [ROM RAM RAM_BLOCK RAM_TEMP
%                                                 MSG FLD MSG_BUFF].
%          mem_bytes = Number of bytes in a memory allocation unit.
%

% --------------------------------------------------------------------------
%
%%  @file       gps_message_defs.m
%   @brief      Build and output GPS Message defs to MIF and VHDL files.
%   @details    Information to parse and store/retrieve from GPS memory
%               is stored in a MIF file and set of VHDL files.
%   @author     Emery Newlon
%   @date       August 2014
%   @copyright  Copyright (C) 2014 Ross K. Snider and Emery L. Newlon

%   This program is free software: you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation, either version 3 of the License, or
%   (at your option) any later version.
%
%   This program is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.
%
%   You should have received a copy of the GNU General Public License
%   along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%   Emery Newlon
%   Electrical and Computer Engineering
%   Montana State University
%   610 Cobleigh Hall
%   Bozeman, MT 59717
%   emery.newlon@msu.montana.edu
%
% --------------------------------------------------------------------------


%   The message information vector is:
%     ROM       Next available address in the ROM.
%     RAM       Next available address in RAM for permanent storage.  The
%               temporary storage area falls after all of the permanent
%               storage.
%     RAM_BLOCK Next RAM block number for permanent storage blocks.
%     RAM_TEMP  Total amount of temporary RAM needed.
%     MSG       Next message number.
%     FLD       Next field number.

mem_info = start_meminfo ;

%   Message ID information is used to build a litteral tree and lookup
%   table.  The litteral tree consists of character nodes and the message
%   number that the node's character ends the message ID string.  The lookup
%   table contains the ROM addresses the message extraction information
%   starts at indexed by message number.

ubx_msg_ids     = cell (1, 2) ;
ubx_msg_cnt     = 0 ;

%   Message Definitions consist of a set of field definitions each row of
%   which has a field name, a field length, and a flag indicating whether
%   the field is saved in memory.

%   Field Definitions for UBX-NAV-SOL Navigation Solution Information
%   message.

ubx_nav_sol     = {'iTOW'       4 1 ;   ...
                   'fTOW'       4 1 ;   ...
                   'week'       2 1 ;   ...
                   'gpsFix'     1 1 ;   ...
                   'flags'      1 0 ;   ...
                   'ecefX'      4 1 ;   ...
                   'ecefY'      4 1 ;   ...
                   'ecefZ'      4 1 ;   ...
                   'pAcc'       4 1 ;   ...
                   'ecefVX'     4 0 ;   ...
                   'ecefVY'     4 0 ;   ...
                   'ecefVZ'     4 0 ;   ...
                   'sAcc'       4 0 ;   ...
                   'pDOP'       2 1 ;   ...
                   'res1'       1 0 ;   ...
                   'numSV'      1 1 ;   ...
                   'res2'       4 0 } ;

msg_id                        = [1 6] ;
msg_name                      = 'msg_ubx_nav_sol' ;

ubx_msg_cnt                   = ubx_msg_cnt + 1 ;

ubx_msg_ids (ubx_msg_cnt, 1)  = {char(msg_id)} ;
ubx_msg_ids (ubx_msg_cnt, 2)  = {mem_info(1)} ;

mem_info = gps_message_out (miffile, mem_info, 1, msg_name, msg_id,   ...
                            'MUNSol', ubx_nav_sol) ;

%   Field Definitions for UBX-NAV-AOPSTATUS AssistNow Autonomous Status
%   message.

ubx_nav_aopstatus = {'iTOW'       4 1 ;   ...
                     'config'     1 1 ;   ...
                     'status'     1 1 ;   ...
                     'res0'       1 0 ;   ...
                     'res1'       1 0 ;   ...
                     'avail'      4 1 ;   ...
                     'res2'       4 0 ;   ...
                     'res3'       4 0 } ;

msg_id                        = [1 96] ;
msg_name                      = 'msg_ubx_nav_aopstatus' ;

ubx_msg_cnt                   = ubx_msg_cnt + 1 ;

ubx_msg_ids (ubx_msg_cnt, 1)  = {char(msg_id)} ;
ubx_msg_ids (ubx_msg_cnt, 2)  = {mem_info(1)} ;

mem_info = gps_message_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                            'MUNAOPstatus', ubx_nav_aopstatus) ;

%   Field Definitions for UBX-TIM-TM2 Time Mark Data message.

ubx_tim_tm2     = {'ch'         1 0 ;   ...
                   'flags'      1 1 ;   ...
                   'count'      2 0 ;   ...
                   'wnR'        2 0 ;   ...
                   'wnF'        2 1 ;   ...
                   'towMsR'     4 0 ;   ...
                   'towSubMsR'  4 0 ;   ...
                   'towMsF'     4 1 ;   ...
                   'towSubMsF'  4 1 ;   ...
                   'accEst'     4 1 } ;

msg_id                        = [13 3] ;
msg_name                      = 'msg_ubx_tim_tm2' ;

ubx_msg_cnt                   = ubx_msg_cnt + 1 ;

ubx_msg_ids (ubx_msg_cnt, 1)  = {char(msg_id)} ;
ubx_msg_ids (ubx_msg_cnt, 2)  = {mem_info(1)} ;

mem_info = gps_message_out (miffile, mem_info, 1, msg_name, msg_id,   ...
                            'MUTTm2', ubx_tim_tm2) ;

%   Build a text tree out of the message IDs and add it to the ROM.

tree          = text_tree (ubx_msg_ids (:, 1)') ;

tree_addr     = mem_info (1) ;

mem_info (1)  = text_tree_out (miffile, tree_addr, tree, ubx_msg_cnt) ;

offset_fld    = 2 ^ (fix (log2 (ubx_msg_cnt)) + 1 + 9) ;

offset_max    = max (fix (single (tree) / offset_fld)) ;

%   Add the ROM start addresses of the message extraction tables to the ROM.

lookup_addr   = mem_info (1) ;

msg_addrs     = [ubx_msg_ids{:, 2}] ;

mem_info      = lookup_tbl_out (miffile, mem_info, msg_addrs) ;

%   Add the message number to message Id translation table to the ROM.

msgno_addr    = mem_info (1) ;

mem_info      = msgno_tbl_out (miffile, mem_info,     ...
                               uint8 ([ubx_msg_ids{:, 1}])) ;

%
%   Add initialization data to the ROM.
%

init_addr     = mem_info (1) ;

%   Clear all automatically generated message by setting their rates to
%   zero.

msg_info      = {'msgClass'   1 240 ;   ...
                 'msgID'      1 0   ;   ...
                 'rate'       6 0   } ;

msg_id        = [6 1] ;
msg_name      = 'msg_ubx_cfg_msg_nmea_gga' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;


msg_info      = {'msgClass'   1 240 ;   ...
                 'msgID'      1 1   ;   ...
                 'rate'       6 0   } ;

msg_id        = [6 1] ;
msg_name      = 'msg_ubx_cfg_msg_nmea_gll' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;


msg_info      = {'msgClass'   1 240 ;   ...
                 'msgID'      1 2   ;   ...
                 'rate'       6 0   } ;

msg_id        = [6 1] ;
msg_name      = 'msg_ubx_cfg_msg_nmea_gsa' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;


msg_info      = {'msgClass'   1 240 ;   ...
                 'msgID'      1 3   ;   ...
                 'rate'       6 0   } ;

msg_id        = [6 1] ;
msg_name      = 'msg_ubx_cfg_msg_nmea_gsv' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;


msg_info      = {'msgClass'   1 240 ;   ...
                 'msgID'      1 4   ;   ...
                 'rate'       6 0   } ;

msg_id        = [6 1] ;
msg_name      = 'msg_ubx_cfg_msg_nmea_rmc' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;


msg_info      = {'msgClass'   1 240 ;   ...
                 'msgID'      1 5   ;   ...
                 'rate'       6 0   } ;

msg_id        = [6 1] ;
msg_name      = 'msg_ubx_cfg_msg_nmea_vtg' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;


msg_info      = {'msgClass'   1 240 ;   ...
                 'msgID'      1 65  ;   ...
                 'rate'       6 0   } ;

msg_id        = [6 1] ;
msg_name      = 'msg_ubx_cfg_msg_nmea_txt' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;

%   Navigation Settings.  Default except that the Dynamic Model is
%   Pedestrian.

msg_info      = {'mask'             2 1   ;   ...
                 'dynModel'         1 3   ;   ...
                 'fixMode'          1 0   ;   ...
                 'fixedAlt'         4 0   ;   ...
                 'fixedAltVar'      4 0   ;   ...
                 'minElev'          1 0   ;   ...
                 'drLimit'          1 0   ;   ...
                 'pDop'             2 0   ;   ...
                 'tDop'             2 0   ;   ...
                 'pAcc'             2 0   ;   ...
                 'tAcc'             2 0   ;   ...
                 'staticHoldThresh' 1 0   ;   ...
                 'dgpsTimeOut'      1 0   ;   ...
                 'cnoThreshNumSVs'  1 0   ;   ...
                 'cnoThresh'        1 0   ;   ...
                 'reserved2'        2 0   ;   ...
                 'reserved3'        4 0   ;   ...
                 'reserved4'        4 0   } ;

msg_id        = [6 36] ;
msg_name      = 'msg_ubx_cfg_nav5' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;

%   Navigation Settings.  Default except that AssistNow Autonomous is turned
%   on.

msg_info      = {'version'          2 0   ;   ...
                 'mask'             2 16384 ; ...
                 'reserved0'        4 0   ;   ...
                 'reserved1'        1 0   ;   ...
                 'reserved2'        1 0   ;   ...
                 'minSVs'           1 0   ;   ...
                 'maxSVs'           1 0   ;   ...
                 'minCNO'           1 0   ;   ...
                 'reserved5'        1 0   ;   ...
                 'iniFix3D'         1 0   ;   ...
                 'reserved6'        1 0   ;   ...
                 'reserved7'        1 0   ;   ...
                 'reserved8'        1 0   ;   ...
                 'wknRollover'      2 0   ;   ...
                 'reserved9'        4 0   ;   ...
                 'reserved10'       1 0   ;   ...
                 'reserved11'       1 0   ;   ...
                 'usePPP'           1 0   ;   ...
                 'aopCfg'           1 1   ;   ...
                 'reserved12'       1 0   ;   ...
                 'reserved13'       1 0   ;   ...
                 'aopOrbMaxErr'     2 0   ;   ...
                 'reserved14'       1 0   ;   ...
                 'reserved15'       1 0   ;   ...
                 'reserved3'        2 0   ;   ...
                 'reserved4'        4 0   } ;

msg_id        = [6 35] ;
msg_name      = 'msg_ubx_cfg_navx5' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;

%   Receiver Power Management.

msg_info      = {'reserved'         1 8   ;   ...
                 'lpMode'           1 1   } ;

msg_id        = [6 17] ;
msg_name      = 'msg_ubx_cfg_rxm' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;

%   Information Messages Allowed.

msg_info      = {'protocolID-NMEA'  1 1   ;   ...
                 'reserved0'        1 0   ;   ...
                 'reserved1'        2 0   ;   ...
                 'infMsgMask'       6 0   } ;

msg_id        = [6 2] ;
msg_name      = 'msg_ubx_cfg_inf' ;

mem_info      = gps_init_out (miffile, mem_info, 0, msg_name, msg_id,   ...
                              msg_info) ;

%   Time Pulse Parameters.

msg_info      = {'tpIdx'              1 0       ;   ...
                 'reserved0'          1 0       ;   ...
                 'reserved1'          2 0       ;   ...
                 'antCableDelay'      2 50      ;   ...
                 'rfGroupDelay'       2 0       ;   ...
                 'freqPeriod'         4 1000000 ;   ...
                 'freqPeriodLock'     4 1000000 ;   ...
                 'pulseLenRatio'      4 0       ;   ...
                 'pulseLenRatioLock'  4 100000  ;   ...
                 'userConfigDelay'    4 0       ;   ...
                 'flags'              4 246     } ;

msg_id        = [6 49] ;
msg_name      = 'msg_ubx_cfg_tp5' ;

mem_info      = gps_init_out (miffile, mem_info, 1, msg_name, msg_id,   ...
                              msg_info) ;

%   Output the message control symbols.

romseg_addr   = [tree_addr lookup_addr msgno_addr init_addr] ;

gps_message_ctl_out (mem_info, romseg_addr, offset_max, msg_addrs,      ...
                     mem_bytes) ;


next_meminfo = mem_info ;
